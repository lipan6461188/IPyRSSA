#-*- coding:utf-8 -*-

import sys
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec
import matplotlib

def stackedBarPlot( stackedBars, stackedLabels, barLabels, stackedColors=None ):
    """
    Plot a stacked bar plot
    
    stackedBars         -- A list
    stackedLabels       -- Labels for each stacked class
    barLabels           -- Labels for each bar
    stackedColors       -- Colors for each stacked class
    
    stackedBars = [ [29, 10, 21], [24, 11, 33] ]
    stackedLabels = ['stack1', 'stack2', 'stack3'] 
    barLabels = ['bar1', 'bar2']
    stackedColors = ['red', 'blue', 'green']
    stackedBarPlot( stackedBars, stackedLabels, barLabels, stackedColors)
    """
    
    import matplotlib.pyplot as plt
    
    def getStackedBarList(stackedBars, stackedLabels, barLabels):
        barList = []
        for bar,bar_label in zip(stackedBars,barLabels):
            for bar_item,stack_label in zip(bar,stackedLabels):
                barList.append( (bar_item, stack_label, bar_label) )
        return barList
    
    assert len(stackedBars) == len(barLabels)
    assert  len(stackedBars[0]) == len(stackedLabels)
    
    if stackedColors:
        assert len(stackedLabels) == len(stackedColors)
    else:
        stackedColors = sns.color_palette("hls", len(stackedLabels))
    
    stackedBarList = getStackedBarList(stackedBars, stackedLabels, barLabels)
    
    last_y = [0]*len(barLabels)
    for i,stack_label in enumerate( stackedLabels ):
        sub_dict = {it[2]:it[0] for it in stackedBarList if it[1]==stack_label}
        
        y = []
        for bar_label in barLabels:
            y.append(sub_dict[bar_label])
        
        plt.bar(range(1,len(barLabels)+1), y, color=stackedColors[i], bottom=last_y, label=stack_label)
        last_y = [ y_i+y_j for y_i,y_j in zip(y, last_y) ]
    
    plt.legend()
    plt.xticks( range(1,len(barLabels)+1), barLabels )
    plt.xticks(rotation=90)

def violin_adjacent_values(vals, q1, q3):
    import numpy
    vals = sorted(vals)
    
    upper_adjacent_value = q3 + (q3 - q1) * 1.5
    upper_adjacent_value = numpy.clip(upper_adjacent_value, q3, vals[-1])
    
    lower_adjacent_value = q1 - (q3 - q1) * 1.5
    lower_adjacent_value = numpy.clip(lower_adjacent_value, vals[0], q1)
    return lower_adjacent_value, upper_adjacent_value

def violin_set_axis_style(ax, labels):
    import numpy
    
    ax.get_xaxis().set_tick_params(direction='out')
    ax.xaxis.set_ticks_position('bottom')
    ax.set_xticks(numpy.arange(1, len(labels) + 1))
    ax.set_xticklabels(labels)
    ax.set_xlim(0.25, len(labels) + 0.75)

def violinPlot(ax, data_list, labels, colors=None, rem_ext=0):
    """
    Plot a violin
    
    ax                  -- Axis generated by plt.subplots
    data_list           -- A list of list
    labels              -- Labels for each list
    colors              -- Colors for each list
    rem_ext             -- Percentage to remove for outliers
    
    Example:
        fig, axs = plt.subplots(nrows=2, ncols=1, figsize=(6, 12), sharey=True)
        axs[0].set_title('smartSHAPE 1 ng')
        axs[0].set_ylabel('smart SHAPE score')
        data = [ np.random.normal(3,1,50),np.random.normal(7,1.5,50),np.random.normal(3,0.8,50),np.random.normal(3,0.4,50) ]
        colors = ['red','blue','green','yellow']
        violinPlot(axs[0], data, ['A', 'T', 'C', 'G'],colors=colors)
        fig.tight_layout()
        fig.show()
    """
    import numpy
    
    if colors == None:
        colors = ['#D43F3A'] * len(data_list)
    else:
        assert len(colors) == len(data_list)
        colors = colors[::-1]
    
    if rem_ext:
        assert 0.0 <= rem_ext <= 0.5
        import copy
        data_list = copy.deepcopy(data_list)
        for idx in range(len(data_list)):
            data_list[idx].sort()
            remNum = int(len(data_list[idx]) * rem_ext)
            start = remNum; end = len(data_list[idx]) - remNum
            data_list[idx] = data_list[idx][start:end]
    
    parts = ax.violinplot(data_list, showmeans=False, showmedians=False, showextrema=False)
    
    for pc in parts['bodies']:
        pc.set_facecolor(colors.pop())
        pc.set_edgecolor('black')
        pc.set_alpha(1)
    
    quartile1 = []; medians = []; quartile3 = []
    for data in data_list:
        quartile1.append( numpy.percentile(data, 25) )
        medians.append( numpy.percentile(data, 50) )
        quartile3.append( numpy.percentile(data, 75) )
    
    whiskers = numpy.array([
        violin_adjacent_values(sorted_array, q1, q3)
        for sorted_array, q1, q3 in zip(data_list, quartile1, quartile3)])
    
    whiskersMin, whiskersMax = whiskers[:, 0], whiskers[:, 1]
    
    inds = numpy.arange(1, len(medians) + 1)
    ax.scatter(inds, medians, marker='o', color='white', s=20, zorder=3)
    ax.vlines(inds, quartile1, quartile3, color='k', linestyle='-', lw=8)
    ax.vlines(inds, whiskersMin, whiskersMax, color='k', linestyle='-', lw=1)
    
    violin_set_axis_style(ax, labels)

def piePlot(data_list, explodes=None, colors=None, labels=None, format=None, labeldistance=1.1):
    """
    Plot a pie
    
    data_list           -- A list of list
    explodes            -- Explodes for each sector
    colors              -- Colors for each sector
    labels              -- Labels for each sector
    format              -- Format of annotation ("%.3f")
    labeldistance       -- The distance of between labels and sector
    
    Example:
        data = [random.random() for i in range(4)]
        
        grids = GridSpec(2, 2)
        
        plt.subplot(grids[0, 0], aspect=1)
        piePlot(data)
        
        plt.subplot(grids[0, 1], aspect=1)
        piePlot(data, labels=['A', 'B', 'C', 'D'])
        
        plt.subplot(grids[1, 0], aspect=1)
        colors=['red', 'blue', 'green', 'yellow']
        explodes=[0.05, 0, 0, 0]
        labels=['A', 'B', 'C', 'D']
        piePlot(data, explodes=explodes, colors=colors, labels=labels, format='%.3f%%')
        
        plt.subplot(grids[1, 1], aspect=1)
        piePlot([10,20,19,20])
        
        plt.show()
    """
    return plt.pie(data_list, explode=explodes, colors=colors, labels=labels, shadow=False, autopct=format, labeldistance=labeldistance)

def boxPlot(ax, data_list, width=0.4, labels=None, title=None, facecolors=None, showmeans=False, meancolors=None, mediancolors=None, showOutliers=False):
    """
    Plot a box
    
    ax                  -- Axis generated by fig.add_subplot
    data_list           -- A list of list
    width               -- Width of each box
    title               -- Figure title
    facecolors          -- Colors for each box
    mediancolors        -- Colors for each median line
    
    Example:
        fig = plt.figure(1, figsize=(5, 6))
        ax = fig.add_subplot(111)
        data_list = [ np.random.normal(3,1,50), np.random.normal(3,6,50), np.random.normal(5,3,50) ]
        labels = ['A','B','C']
        facecolors = ['red','blue','green']
        boxPlot(ax, data_list, labels=labels, facecolors=facecolors)
        fig.show()
    """
    obj = ax.boxplot(x=data_list, showfliers=showOutliers, patch_artist=True, widths=width, showmeans=showmeans, meanline=showmeans)
    
    if facecolors is None:
        facecolors = ['#2196f3']*len(data_list)
    if mediancolors is None:
        mediancolors = ['white']*len(data_list)
    
    if meancolors is None:
        meancolors = ['#9c27b0']*len(data_list)
    
    for i,box in enumerate(obj['boxes']):
        box.set( color='#7570b3', linewidth=0.5)
        box.set( facecolor = facecolors[i] )
    
    for whisker in obj['whiskers']:
        whisker.set(color='black', linewidth=2)
    
    for cap in obj['caps']:
        cap.set(color='black', linewidth=2)
    
    for i,median in enumerate(obj['medians']):
        median.set(color=mediancolors[i], linewidth=2)
    
    if 'means' in obj:
        for i,mean in enumerate(obj['means']):
            mean.set(color=meancolors[i], linewidth=1)
    
    for flier in obj['fliers']:
        flier.set(marker='o', color='#e7298a', alpha=0.5)
    
    if labels:
        ax.set_xticklabels(labels)
    
    if title:
        ax.set_title(title).set_weight("bold")
    
    ax.get_xaxis().tick_bottom()
    ax.get_yaxis().tick_left()
    
    return obj

def cdf(data, color='black', linestyle='--', label=None):
    """
    data            -- A list, [1,2,3,4...]
    """
    import numpy as np
    data_size=len(data)
    # Set bins edges
    data_set=sorted(set(data))
    bins=np.append(data_set, data_set[-1]+1)
    # Use the histogram function to bin the data
    counts, bin_edges = np.histogram(data, bins=bins, density=False)
    counts = counts.astype(float)/data_size
    # Find the cdf
    cdf_ = np.cumsum(counts)
    # Plot the cdf
    plt.plot(bin_edges[0:-1], cdf_, linestyle=linestyle, color=color, label=label)
    plt.ylim((0,1))
    plt.ylabel("CDF")
    #plt.grid(True)

def annotate(axs, text, location='top left'):
    """
    axs             --  Axis, use plt.gca() to get current axis
    text            --  Text to annotate
    location        --  top left / to center / top right /
                        bottom left / bottom center / bottom right
    """
    if location == 'top left':
        xy = (0.02, 0.98)
        axs.annotate(s=text, xycoords='axes fraction', xy=xy, horizontalalignment='left', verticalalignment='top')
    elif location == 'top center':
        xy = (0.5, 0.98)
        axs.annotate(s=text, xycoords='axes fraction', xy=xy, horizontalalignment='center', verticalalignment='top')
    elif location == 'top right':
        xy = (0.98, 0.98)
        axs.annotate(s=text, xycoords='axes fraction', xy=xy, horizontalalignment='right', verticalalignment='top')
    elif location == 'bottom left':
        xy = (0.02, 0.02)
        axs.annotate(s=text, xycoords='axes fraction', xy=xy, horizontalalignment='left', verticalalignment='bottom')
    elif location == 'bottom center':
        xy = (0.5, 0.02)
        axs.annotate(s=text, xycoords='axes fraction', xy=xy, horizontalalignment='center', verticalalignment='bottom')
    elif location == 'bottom right':
        xy = (0.98, 0.02)
        axs.annotate(s=text, xycoords='axes fraction', xy=xy, horizontalalignment='right', verticalalignment='bottom')
    else:
        raise RuntimeError("location Error")

def rainbowPlot(probList, ax, length=None, lw=0.8, prob_cutoff=[0.8, 0.3, 0.1, 0.03]):
    """
    This is a function to plot the RNA secondary structure with probability.
    
    probList                -- [[3, 135, 0.15], ...]. Returned by Structure.partition
    ax                      -- plt.subplots return
    length                  -- The length of the RNA
    lw                      -- Line width
    prob_cutoff             -- The cutoff of the probability of base pairing
    
    fig, ax = plt.subplots(figsize=(12,3))
    probList = [[3, 135, 0.15], [4, 134, 0.16], [5, 133, 0.15], [7, 33, 1.0], [8, 32, 1.0], [9, 31, 1.0], [10, 30, 1.0], [11, 29, 0.95], [13, 26, 0.98], [14, 25, 1.0], [15, 24, 1.0], [16, 23, 1.0], [17, 22, 0.98], [45, 59, 1.0], [46, 58, 1.0], [47, 57, 1.0], [48, 56, 1.0], [49, 55, 0.99], [61, 75, 1.0], [62, 74, 1.0], [63, 73, 1.0], [64, 72, 1.0], [82, 130, 0.41], [83, 129, 0.42], [84, 127, 1.0], [85, 126, 1.0], [86, 125, 1.0], [87, 124, 1.0], [88, 123, 1.0], [89, 122, 1.0], [90, 121, 1.0], [91, 120, 0.98], [93, 118, 0.99], [94, 117, 0.99], [96, 116, 0.99], [97, 115, 1.0], [98, 114, 1.0], [99, 113, 1.0], [101, 111, 1.0], [102, 110, 1.0], [103, 109, 1.0], [150, 294, 0.93], [151, 293, 1.0], [152, 292, 1.0], [153, 291, 1.0], [154, 290, 1.0], [155, 289, 1.0], [156, 288, 1.0], [157, 284, 1.0], [158, 283, 1.0], [159, 282, 1.0], [160, 281, 1.0], [163, 279, 0.99], [164, 278, 1.0], [165, 277, 1.0], [166, 276, 1.0], [167, 275, 1.0], [171, 273, 1.0], [172, 272, 1.0], [173, 271, 1.0], [175, 270, 1.0], [176, 269, 1.0], [177, 268, 1.0], [178, 267, 1.0], [179, 266, 1.0], [180, 265, 1.0], [181, 264, 1.0], [182, 263, 0.81], [183, 227, 0.98], [184, 226, 0.99], [185, 225, 0.99], [188, 218, 1.0], [189, 217, 1.0], [190, 216, 1.0], [191, 215, 1.0], [192, 214, 1.0], [193, 213, 1.0], [195, 210, 0.94], [196, 209, 1.0], [197, 208, 1.0], [198, 207, 1.0], [199, 206, 1.0], [228, 252, 1.0], [229, 251, 1.0], [230, 250, 1.0], [231, 249, 1.0], [232, 248, 1.0], [233, 247, 1.0], [234, 246, 0.97], [236, 245, 0.98], [237, 244, 0.98], [253, 262, 0.92], [254, 261, 1.0], [255, 260, 1.0]]
    rainbowPlot(probList, ax, 300)
    plt.show()
    """
    import Colors
    max_height = 0
    for left,right,prob in probList:
        color = ""
        if prob>prob_cutoff[0]:
            color = Colors.RGB['green']
        elif prob>prob_cutoff[1]:
            color = Colors.RGB['blue']
        elif prob>prob_cutoff[2]:
            color = Colors.RGB['yellow']
        elif prob>prob_cutoff[3]:
            color = Colors.RGB['gray']
        if color:
            x = (left+right)/2
            width = (right-left)
            height = width*0.01
            max_height = max(max_height, height/2)
            circle = matplotlib.patches.Arc((x, 0), width=width, color=color, angle=0, height=height, theta1=0, theta2=180, lw=lw)
            tmp = ax.add_artist(circle)
    ax.set_ylim(0, max_height)
    ax.set_yticklabels([], [])
    ax.set_yticks([])
    
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_visible(False)
    
    if length:
        ax.set_xlim(1, length)


def scatterPlot(df, x, y, label=None, hue=None, hue_vmin=None, hue_vcenter=None, hue_vmax=None,
                legend='auto', palette=None, unit_scalling_factor=20):
    """
    Scatter plot with text labels
    
    Example:

    df = ...
    x = 'xTFold'
    y = 'None_10_None_1.2_256'
    hue = 'None_10_None_1.2_256_MSANum'
    hue_vmin, hue_vcenter, hue_vmax = 0, 50, 200
    legend = False
    palette = sns.color_palette("coolwarm", as_cmap=True)
    unit_scalling_factor = 20
    plt.figure(figsize=(10,10))
    ax = scatterplot(df_1, x, y, label=label, hue=hue, hue_vmin=hue_vmin, hue_vcenter=hue_vcenter, hue_vmax=hue_vmax, legend=legend, palette=palette, unit_scalling_factor=unit_scalling_factor)
    ax.plot([0.1,1], [0.1,1], '-.')
    plt.savefig(join(HOME, 'Figures', 'xtFold_vs_retrieval_casp15.pdf'))
    plt.close()
    """
    import seaborn as sns
    import matplotlib as mpl
    
    if palette is None:
        palette = sns.color_palette("coolwarm", as_cmap=True)
    
    ax = sns.scatterplot(data=df, x=x, y=y, hue=hue, 
                   linewidth=0.2, edgecolor='black', 
                   hue_norm=mpl.colors.TwoSlopeNorm(vmin=hue_vmin, vcenter=hue_vcenter, vmax=hue_vmax),
                   legend=legend,
                   palette=palette)
    
    xmin, xmax = ax.get_xbound()
    ymin, ymax = ax.get_ybound()
    unit_x, unit_y = (xmax - xmin) / unit_scalling_factor, (ymax - ymin) / unit_scalling_factor
    
    if label is not None:
        names = df.loc[:, label].values
        xy = df.loc[:, (x, y)].values
        for idx in range(len(xy)):
            x,y = xy[idx]
            name = names[idx]
            mask = (xy[:, 0]>=x-unit_x) & (xy[:, 0]<=x+unit_x) & (xy[:, 1]>=y-unit_y) & (xy[:, 1]<=y)
            if mask.sum() <= 1:
                ax.text( x, y, name, verticalalignment='top', horizontalalignment='center' )
    return ax

##########################
## Matplotlib related functions
##########################

DEFAULT_FONT_FAMILY = plt.rcParams["font.family"]
DEFAULT_FONT_SERIF  = plt.rcParams["font.serif"]

def set_matplotlib_font(family=None, serif=None, weight=None, size=None):
    """
    Parameters
    ----------------
    family: ['sans-serif']
    serif: ['DejaVu Serif', 'Bitstream Vera Serif', 'Computer Modern Roman', 'New Century Schoolbook', 'Century Schoolbook L', 'Utopia', 'ITC Bookman', 'Bookman', 'Nimbus Roman No9 L', 'Times New Roman', 'Times', 'Palatino', 'Charter', 'serif']
    weight: 'normal'
    size: 10
    
    To get all parameters: matplotlib.rcParams
    """
    import matplotlib
    import matplotlib.pyplot as plt
    
    if family is not None:
        plt.rcParams["font.family"] = family
    if serif is not None:
        plt.rcParams["font.serif"] = serif
    if weight is not None:
        plt.rcParams["font.weight"] = weight
    if size is not None:
        plt.rcParams["font.size"] = size


